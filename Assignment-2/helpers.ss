;;; helpers.ss
;;; Copyright (c) 2000-2009 R. Kent Dybvig, Andy Keep, Oscar Waddell, Daniel P. Friedman
;;;
;;; In this file:
;;;
;;;   (define-who id defn ... expr) is a syntactic form that defines id
;;;   to be the value of (let () defn ... expr) and, within the let,
;;;   defines the variable who to be 'id.
;;;
;;;   (sra x n) shifts x right by n bits
;;;
;;;   (stack-size) returns the current stack size in 8-byte words
;;;   (stack-size n) sets the stack size to n
;;;
;;;   (heap-size) returns the current heap size in 8-byte words
;;;   (heap-size n) sets the heap size to n
;;;
;;;   (mref reg reg/offset) references the stack or heap memory at
;;;   effective address reg + reg/offset
;;;
;;;   (mset! reg reg/offset x) sets the stack or heap memory at
;;;   effective address reg + reg/offset to x
;;;
;;;   (int32? x) returns true iff x is a 32-bit exact integer
;;;
;;;   (int64? x) returns true iff x is a 64-bit exact integer
;;;
;;;   (uint6? x) returns true iff x is an unsigned 6-bit exact integer
;;;
;;;   (register? x) returns true iff x is a register
;;;
;;;   rax, rcx, rdx, rbx, rbp, rsi, rdi, r8, r9, r10, r11, r12,
;;;   r13, r14, r15 are all defined and set to zero
;;;
;;;   (max-frame-var) returns the current max frame var set up by the system.
;;;   (max-frame-var n) sets the max frame var to n
;;;   
;;;   fv0, fv1, ..., fvN, where N is (max-frame-var), are all defined
;;;   to refer to the proper frame location within the stack, based
;;;   at rbp, e.g., a reference to fv3 is a reference to the stack
;;;   at location ebp + 24.  The offset is 24 rather than 3 since
;;;   each word is 8-bytes.
;;;
;;;   (frame-var? x) returns true iff x is a frame-var in the range
;;;
;;;   (frame-var->index fv) returns the frame variable's index, e.g.,
;;;   the call (frame-var->index 'fv3) returns 3.
;;;
;;;   fv0, fv1, ..., fvN, where N is (max-frame-var)
;;;
;;;   (label? x) returns true iff x is a label
;;;
;;;   (extract-root name) extracts the root of name, i.e., the part
;;;   before the last dollar sign ($) or period (.).
;;;
;;;   (extract-suffix name) extracts the suffix of name, i.e., the part
;;;   after the last dollar sign ($) or period (.).
;;;
;;;   (make-disp-opnd reg offset) returns a disp-opnd record, used to
;;;   represent a displacement-mode operand
;;;
;;;   (disp-opnd? x) returns true iff x is a disp-opnd
;;;
;;;   (disp-opnd-reg disp-opnd) returns the disp-opnd's register
;;;
;;;   (disp-opnd-offset disp-opnd) returns the disp-opnd's offset
;;;
;;;   (make-index-opnd reg offset) returns an index-opnd record, used to
;;;   represent a index-mode operand
;;;
;;;   (index-opnd? x) returns true iff x is a index-opnd
;;;
;;;   (index-opnd-breg index-opnd) returns the index-opnd's base register
;;;
;;;   (index-opnd-ireg index-opnd) returns the index-opnd's index register
;;;
;;;   (label->x86-64-label label) returns a string of the form Ln, where
;;;   n is label's suffix.  used by emit.
;;;
;;;   (rand->x86-64-arg operand) returns a string representing the
;;;   operand, with integers prefixed by $, registers prefixed by
;;;   %, labels converted to rip-relative operands, disp-opnds
;;;   converted to displacement-mode syntax, and index-opnds converted
;;;   to index-mode syntax.  used by emit.
;;;
;;;   (emit-label label) emits label on a line by itself, followed
;;;   by a colon.
;;;
;;;   (emit opcode opnd ...) emits the instruction described by
;;;   opcode and opnd ....  The operands are automatically formatted
;;;   with the help of rand->x86-64-arg.  Use for everything except
;;;   jump instructions.
;;;
;;;   (emit-jump opcode opnd) emits a jump instruction, using the
;;;   peculiar syntax required for jumps.
;;;
;;;   (emit-program code code ...) emits the boilerplate code with
;;;   the code generated by code code ... embedded within it.
;;;
;;;   (make-begin expr*) is flattens begin expressions in expr* and
;;;   tacks the symbol begin on the front of the list, except if the
;;;   list has one element, in which case it returns the element.
;;;   expr* should be nonempty.  E.g., (make-begin '(e1)) => e1 and
;;;   (make-begin '(e1 (begin (begin e2 e3) e4) e5)) =>
;;;   (begin e1 e2 e3 e4 e5).
;;;
;;; This file also sets up record writers for disp-opnd and index-opnd
;;; records and redefine's match's equality check to handle disp-opnds
;;; and index-opnds

(load "match.ss")

(define-syntax define-who
  (lambda (x)
    (syntax-case x ()
      [(k name defn ... expr)
       (with-syntax ([who (datum->syntax-object #'k 'who)])
         #'(define name
             (let ([who 'name])
               defn ...
               expr)))])))

;;; language extensions

(define sra (lambda (x n) (ash x (- n))))

;;; memory

(define align-shift 3) ; 8-byte words

(module (heap-size stack-size mref mset!)
  (define heap-offset 0)
  (define stack-offset (/ (+ (most-positive-fixnum) 1) 2))

  (define the-heap '#())
  (define the-stack '#())

  (define-who heap-size
    (make-parameter 100000
      (lambda (n)
        (unless (and (fixnum? n) (fx>= n 0))
          (error who "invalid size ~s" n))
        (unless (fx= n (vector-length the-heap))
          (set! the-heap (make-vector n))))))

  (define-who stack-size
    (make-parameter 100000
      (lambda (n)
        (unless (and (fixnum? n) (fx>= n 0))
          (error who "invalid size ~s" n))
        (unless (fx= n (vector-length the-stack))
          (set! the-stack (make-vector n))))))

  (define-who mref
    (lambda (x y)
      (let ([i (fxsrl (fx+ x y) align-shift)])
        (cond
          [(fx< i 0)
           (error who "attempt to reference below heap at index ~s" i)]
          [(fx< i (vector-length the-heap))
           (vector-ref the-heap i)]
          [(fx< i (fx- stack-offset 1000))
           (error who "attempt to reference above heap at index ~s" i)]
          [else
           (let ([i (fx- i stack-offset)])
             (cond
               [(fx< i 0)
                (error who "attempt to reference below stack at index ~s" i)]
               [(fx< i (vector-length the-stack))
                (vector-ref the-stack i)]
               [else (error who "attempt to reference above heap at index ~s" i)]))]))))

  (define-who mset!
    (lambda (x y z)
      (let ([i (fxsrl (fx+ x y) align-shift)])
        (cond
          [(fx< i 0)
           (error who "attempt to reference below heap at index ~s" i)]
          [(fx< i (vector-length the-heap))
           (vector-set! the-heap i z)]
          [(fx< i (fx- stack-offset 1000))
           (error who "attempt to reference above heap at index ~s" i)]
          [else
           (let ([i (fx- i stack-offset)])
             (cond
               [(fx< i 0)
                (error who "attempt to reference below stack at index ~s" i)]
               [(fx< i (vector-length the-stack))
                (vector-set! the-stack i z)]
               [else (error who "attempt to reference above heap at index ~s" i)]))])))))

;;; integers

(define int32?
  (lambda (x)
    (and (and (integer? x) (exact? x))
         (<= (- (expt 2 31)) x (- (expt 2 31) 1)))))

(define int64?
  (lambda (x)
    (and (and (integer? x) (exact? x))
         (<= (- (expt 2 63)) x (- (expt 2 63) 1)))))

(define uint6?
  (lambda (x)
    (and (and (integer? x) (exact? x)) (<= 0 x 63))))

;;; registers

(define register?
  (lambda (x)
    (memq x '(rax rcx rdx rbx rbp rsi rdi r8 r9 r10 r11 r12 r13 r14 r15))))

(define rax 0)
(define rcx 0)
(define rdx 0)
(define rbx 0)
(define rbp 0)
(define rsi 0)
(define rdi 0)
(define r8 0)
(define r9 0)
(define r10 0)
(define r11 0)
(define r12 0)
(define r13 0)
(define r14 0)
(define r15 0)

;;; frame variables

(define max-frame-var
  (make-parameter 100
    (let ([next 0])
      (lambda (n)
        (unless (and (fixnum? n) (fx>= n 0))
          (error 'max-frame-var "invalid max ~s" n))
        (when (fx>= n next)
          (do ([i next (fx+ i 1)])
              ((fx>= i n))
            (let ([fvi (string->symbol (format "fv~s" i))])
              (eval `(define-syntax ,fvi
                       (identifier-syntax
                         [var (mref rbp ,(fxsll i align-shift))]
                         [(set! var val) (mset! rbp ,(fxsll i align-shift) val)])))
              (putprop fvi 'frame-index i)))
          (set! next n))))))

(define frame-var?
  (lambda (x)
    (and (symbol? x) (getprop x 'frame-index #f) #t)))

(define frame-var->index
  (lambda (fv)
    (getprop fv 'frame-index)))

;;; labels

(define label?
  (lambda (x)
    (and (symbol? x)
      (let* ([s (symbol->string x)] [n (string-length s)])
        (define (s0 i)
          (and (not (fx= i -1))
            (cond
              [(char<=? #\0 (string-ref s i) #\9) (s1 (fx- i 1))]
              [else #f])))
        (define (s1 i)
          (and (not (fx= i -1))
            (let ([c (string-ref s i)])
              (cond
                [(char<=? #\1 (string-ref s i) #\9) (s1 (fx- i 1))]
                [(char=? c #\$) #t]
                [(char=? c #\0) (s2 (fx- i 1))]
                [else #f]))))
        (define (s2 i)
          (and (not (fx= i -1))
            (let ([c (string-ref s i)])
              (cond
                [(char<=? #\1 (string-ref s i) #\9) (s1 (fx- i 1))]
                [(char=? c #\0) (s2 (fx- i 1))]
                [else #f]))))
        (s0 (fx- n 1))))))

(define extract-root
  (lambda (sym)
    (list->string
      (let ([chars (string->list (symbol->string sym))])
        (define (s0 ls)
          (cond
            [(null? ls) chars]
            [(char-numeric? (car ls)) (s1 (cdr ls))]
            [else chars]))
        (define (s1 ls)
          (cond
            [(null? ls) chars]
            [(char-numeric? (car ls)) (s1 (cdr ls))]
            [(memv (car ls) '(#\. #\$)) (reverse (cdr ls))]
            [else chars]))
        (s0 (reverse chars))))))

(define extract-suffix
  (lambda (sym)
    (let ([str (symbol->string sym)])
      (let ([n (string-length str)]
            [m (string-length (extract-root sym))])
        (and (not (= n m))
             (substring str (+ m 1) n))))))

(define label->x86-64-label
  (lambda (lab)
    (format "L~a" (extract-suffix lab))))

;;; operands

(define-record disp-opnd (reg offset))
(define-record index-opnd (breg ireg))
(module ()
  (record-writer (type-descriptor disp-opnd)
    (lambda (x p wr)
      (display-string "#<disp " p)
      (wr (disp-opnd-reg x) p)
      (display-string " " p)
      (wr (disp-opnd-offset x) p)
      (display-string ">" p)))

  (record-writer (type-descriptor index-opnd)
    (lambda (x p wr)
      (display-string "#<index " p)
      (wr (index-opnd-breg x) p)
      (display-string " " p)
      (wr (index-opnd-ireg x) p)
      (display-string ">" p)))

  (match-equality-test
    (lambda (x y)
      (cond
        [(disp-opnd? x)
         (and (disp-opnd? y)
           (eq? (disp-opnd-reg x) (disp-opnd-reg y))
           (= (disp-opnd-offset x) (disp-opnd-offset y)))]
        [(index-opnd? x)
         (and (index-opnd? y)
           (eq? (index-opnd-breg x) (index-opnd-breg y))
           (eq? (index-opnd-ireg x) (index-opnd-ireg y)))]
        [else (equal? x y)]))))

(define-who rand->x86-64-arg
  (lambda (rand)
    (cond
      [(string? rand) rand] ; precooked operand
      [(number? rand)  (format "$~s" rand)]
      [(register? rand)  (format "%~s" rand)]
      [(label? rand) (format "~a(%rip)" (label->x86-64-label rand))]
      [(disp-opnd? rand) (format "~s(%~s)" (disp-opnd-offset rand) (disp-opnd-reg rand))]
      [(index-opnd? rand) (format "(%~s, %~s)" (index-opnd-breg rand) (index-opnd-ireg rand))]
      [else (error who "invalid instruction argument ~s" rand)])))

;;; emit routines

(define emit-label
  (lambda (label)
    (if (string? label)
        (printf "~a:\n" label)
        (printf "~a:\n" (label->x86-64-label label)))))

(define-syntax emit
  (syntax-rules ()
    [(_ opcode) (printf "    ~a\n" opcode)]
    [(_ opcode rand)
     (printf "    ~a ~a\n" opcode (rand->x86-64-arg rand))]
    [(_ opcode rand1 rand2)
     (printf "    ~a ~a, ~a\n" opcode
       (rand->x86-64-arg rand1)
       (rand->x86-64-arg rand2))]))

(define-syntax emit-jump
  (syntax-rules ()
    [(_ opcode ?target)
     (let ([target ?target])
       (if (label? target)
           (emit opcode (label->x86-64-label target))
           (emit opcode (format "*~a" (rand->x86-64-arg target)))))]))

(define-syntax emit-program
  (syntax-rules ()
    [(_ code code* ...)
     (begin
       (emit '.globl "_scheme_entry")
       (emit-label "_scheme_entry")
       (emit 'pushq 'rbx)
       (emit 'pushq 'rbp)
       (emit 'pushq 'r12)
       (emit 'pushq 'r13)
       (emit 'pushq 'r14)
       (emit 'pushq 'r15)
       (emit 'movq 'rdi 'rbp)
       (emit 'leaq "_scheme_exit(%rip)" 'r15)
       code code* ...
       (emit-label "_scheme_exit")
       (emit 'popq 'r15)
       (emit 'popq 'r14)
       (emit 'popq 'r13)
       (emit 'popq 'r12)
       (emit 'popq 'rbp)
       (emit 'popq 'rbx)
       (emit 'ret))]))

;;; other helpers for coding the compiler passes

(define make-begin
  (lambda (expr*)
    (define strip-begin
      (lambda (expr*)
        (match `(begin ,@expr*)
          [(begin ,[expr*] ...) (apply append expr*)]
          [,expr (list expr)])))    
    (match (strip-begin expr*)
      [(,x) x]
      [(,x ,x* ...) `(begin ,x ,x* ...)])))

